/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package ru.nsu.fit.chernikov.Task_2_1_1;

import java.util.ArrayList;
import java.util.Date;
import java.util.Random;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class Pizzeria {
  private BlockingQueue<Order> pendingOrders;
  private BlockingQueue<Order> warehouse;

  private ArrayList<Cook> cooks;
  private ArrayList<Courier> couriers;

  public Log log;

  private Date shiftEnd;
  private long delayLimit; // Milliseconds

  private double income;

  Order takeCookingOrder() {
    Order take = null;
    try {
      take = pendingOrders.poll(timeUntilShiftEnd(), TimeUnit.MILLISECONDS);
    } catch (InterruptedException e) {
      log.logException(e);
    }
    return take;
  }

  boolean putInWarehouse(Order order) {
    boolean res = false;
    try {
      res = warehouse.offer(order, timeUntilShiftEnd(), TimeUnit.MILLISECONDS);
    } catch (InterruptedException e) {
      log.logException(e);
    }
    return res;
  }

  Order takeDeliveryOrder() {
    Order take = null;
    try {
      take = warehouse.take();
    } catch (InterruptedException e) {
      log.logException(e);
    }
    return take;
  }

  ArrayList<Order> fillTrunk(int capacity) {
    if (capacity <= 0) {
      throw new IllegalArgumentException("capacity must be positive");
    }
    ArrayList<Order> trunk = new ArrayList<>(capacity);
    try {
      Order nextOrder = warehouse.poll(timeUntilShiftEnd(), TimeUnit.MILLISECONDS);
      if (nextOrder != null) {
        trunk.add(nextOrder);
        capacity--;
      }
    } catch (InterruptedException e) {
      log.logException(e);
    }
    while (capacity > 0) {
      Order nextOrder = warehouse.poll();
      if (nextOrder == null) {
        break;
      }
      trunk.add(nextOrder);
      capacity--;
    }
    return trunk;
  }

  synchronized void checkout(double payment) {
    income += payment;
  }

  private void setShiftEnd(long delta) {
    Date now = new Date();
    long end = now.getTime() + delta * 1000;
    shiftEnd = new Date(end);
  }

  public Pizzeria() {
    log = new Log();
    setShiftEnd(6);
    cooks = new ArrayList<>();
    couriers = new ArrayList<>();
    pendingOrders = new LinkedBlockingQueue<>();
    warehouse = new ArrayBlockingQueue<>(10);
    delayLimit = 5500;
  }

  public Pizzeria(int whLimit, long timeLimit) {
    log = new Log();
    setShiftEnd(timeLimit);
    cooks = new ArrayList<>();
    couriers = new ArrayList<>();
    pendingOrders = new LinkedBlockingQueue<>();
    warehouse = new ArrayBlockingQueue<>(whLimit);
  }

  public void addCook(String name, double tpu) {
    Cook newCook = new Cook(name, this, tpu);
    newCook.start();
    cooks.add(newCook);
  }

  public void addCourier(String name, double speed, int capacity) {
    Courier courier = new Courier(name, this, speed, capacity);
    courier.start();
    couriers.add(courier);
  }

  public void addOrder(Order order) {
    try {
      pendingOrders.put(order);
    } catch (InterruptedException e) {
      log.logException(e);
    }
  }

  public long getDateDiff(Date date1, Date date2, TimeUnit timeUnit) {
    long diffInMillies = date2.getTime() - date1.getTime();
    return timeUnit.convert(diffInMillies, TimeUnit.MILLISECONDS);
  }

  public long timeUntilShiftEnd() {
    Date now = new Date();
    return getDateDiff(now, shiftEnd, TimeUnit.MILLISECONDS);
  }

  public Date getShiftEnd() {
    return shiftEnd;
  }

  public long getDelayLimit() {
    return delayLimit;
  }

  public static void main(String[] args) {
    Pizzeria PpJhns = new Pizzeria();
    PpJhns.addCook("Vova", 1);
    PpJhns.addCook("Kolya", 1);
    PpJhns.addCook("Mr. Dimples", 0.3);
    PpJhns.addCook("Papa", 0.2);
    PpJhns.addCourier("Sonic", 80, 3);
    PpJhns.addCourier("Tails", 45, 5);
    PpJhns.addCourier("Knuckles", 35, 6);
    for (int i = 0; i < 35; i++) {
      Random rnd = new Random();
      int x = rnd.nextInt(41) - 20;
      int y = rnd.nextInt(41) - 20;
      Order newOrd = new Order(1.0 + Math.sqrt(i), 100, i, new Date(), x, y);
      PpJhns.addOrder(newOrd);
      try{
      Thread.sleep(100);
      } catch (InterruptedException e){
        PpJhns.log.logException(e);
      }
    }
    try {
      for (Cook cook : PpJhns.cooks) {
        System.out.println("Waiting for "+cook.getCName());
        System.out.flush();
        cook.join();
      }
      for (Courier courier : PpJhns.couriers) {
        System.out.println("Waiting for "+courier.getCName());
        System.out.flush();
        courier.join();
      }
    } catch (Exception e) {
      System.err.println(e.toString());
    }
    PpJhns.log.logStatistics();
  }
}
