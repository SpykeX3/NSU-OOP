/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package ru.nsu.fit.chernikov.Task_2_1_1;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

/**
 * Pizzeria is a system that gets orders, produces them and delivers. It must have cook and courier.
 */
public class Pizzeria {
  private BlockingQueue<Order> pendingOrders;
  private BlockingQueue<Order> warehouse;

  private ArrayList<Cook> cooks;

  private ArrayList<Courier> couriers;

  public Log log;

  private Date shiftEnd;

  private long delayLimit; // Milliseconds

  private long shiftLength; // Milliseconds

  private double income;

  /**
   * Method for cooks. Extracts order from queue.
   *
   * @return order or null if shift has ended.
   */
  Order takeCookingOrder() {
    Order take = null;
    try {
      take = pendingOrders.poll(timeUntilShiftEnd(), TimeUnit.MILLISECONDS);
    } catch (InterruptedException e) {
      log.logException(e);
    }
    return take;
  }

  /**
   * Puts ready order in warehouse.
   *
   * @param order product to store.
   * @return true if order was put, false if shift has ended.
   */
  boolean putInWarehouse(Order order) {
    boolean res = false;
    try {
      res = warehouse.offer(order, timeUntilShiftEnd(), TimeUnit.MILLISECONDS);
    } catch (InterruptedException e) {
      log.logException(e);
    }
    return res;
  }

  /**
   * Take orders from warehouse.
   *
   * @param capacity maximum number of orders to take.
   * @return list of taken orders.
   */
  ArrayList<Order> fillTrunk(int capacity) {
    if (capacity <= 0) {
      throw new IllegalArgumentException("capacity must be positive");
    }
    ArrayList<Order> trunk = new ArrayList<>(capacity);
    try {
      Order nextOrder = warehouse.poll(timeUntilShiftEnd(), TimeUnit.MILLISECONDS);
      if (nextOrder != null) {
        trunk.add(nextOrder);
        capacity--;
      }
    } catch (InterruptedException e) {
      log.logException(e);
    }
    while (capacity > 0) {
      Order nextOrder = warehouse.poll();
      if (nextOrder == null) {
        break;
      }
      trunk.add(nextOrder);
      capacity--;
    }
    return trunk;
  }

  /**
   * Register payment.
   *
   * @param payment recieved payment.
   */
  synchronized void checkout(double payment) {
    income += payment;
  }

  /**
   * Set end of shift in delta seconds from now.
   *
   * @param delta length of shift in seconds.
   */
  private void setShiftEnd(long delta) {
    Date now = new Date();
    long end = now.getTime() + delta * 1000;
    shiftEnd = new Date(end);
  }

  /**
   * Pizzeria constructor.
   *
   * @param _cooks list of cooks.
   * @param _couriers list of couriers.
   * @param whLimit warehouse limit.
   * @param delayLim acceptable time to deliver product.
   * @param shiftLen shift duration in seconds.
   */
  public Pizzeria(
      ArrayList<Cook> _cooks,
      ArrayList<Courier> _couriers,
      int whLimit,
      long delayLim,
      long shiftLen) {
    cooks = _cooks;
    couriers = _couriers;
    warehouse = new ArrayBlockingQueue<>(whLimit, true);
    pendingOrders = new LinkedBlockingQueue<>();
    delayLimit = delayLim;
    shiftLength = shiftLen;
    log = new Log();
  }

  /** Run Pizzeria. Prints log while running. */
  public void run() {
    setShiftEnd(shiftLength);
    for (Cook c : cooks) {
      c.setWorkplace(this);
      c.start();
    }
    for (Courier cr : couriers) {
      cr.setWorkplace(this);
      cr.start();
    }
    for (Cook ck : cooks) {
      try {
        ck.join();
      } catch (InterruptedException e) {
        log.logException(e);
      }
    }
    for (Courier ck : couriers) {
      try {
        ck.join();
      } catch (InterruptedException e) {
        log.logException(e);
      }
    }
    log.logStatistics();
  }

  /**
   * Place new order.
   *
   * @param order request.
   */
  public void addOrder(Order order) {
    log.logOrderReceived(order);
    try {
      pendingOrders.put(order);
    } catch (InterruptedException e) {
      log.logException(e);
    }
  }

  /**
   * Calculate difference between two dates.
   *
   * @param date1 before date.
   * @param date2 after date.
   * @param timeUnit unit of time measurement.
   * @return difference in selected units.
   */
  long getDateDiff(Date date1, Date date2, TimeUnit timeUnit) {
    long diffInMillis = date2.getTime() - date1.getTime();
    return timeUnit.convert(diffInMillis, TimeUnit.MILLISECONDS);
  }

  /**
   * Get time until end of shift in milliseconds.
   *
   * @return time until end of shift.
   */
  public long timeUntilShiftEnd() {
    Date now = new Date();
    return getDateDiff(now, shiftEnd, TimeUnit.MILLISECONDS);
  }

  public Date getShiftEnd() {
    return shiftEnd;
  }

  public long getDelayLimit() {
    return delayLimit;
  }

  /**
   * Example Pizzeria program.
   *
   * @param args unused :(
   */
  public static void main(String[] args) {
    File flPizza = new File("src/main/resources/configPizzeria.json");
    File flClients = new File("src/main/resources/configClients.json");
    try {
      Pizzeria pz = Config.parse(new FileReader(flPizza));
      Clients cl = new Clients(pz, new FileReader(flClients));
      cl.start();
      pz.run();
    } catch (IOException e) {
      System.err.println(e.toString());
    }
  }
}
