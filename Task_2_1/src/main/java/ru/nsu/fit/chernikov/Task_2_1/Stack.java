/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package ru.nsu.fit.chernikov.Task_2_1;

import java.util.EmptyStackException;
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * LIFO (FILO) container. Stack has non-negative capacity that is extended when exceeded.
 *
 * @param <T> type of stack elements
 */
public class Stack<T> implements Iterable<T> {
  private Object[] array;
  private int size, cap;

  private class NonDestructiveIterator implements java.util.Iterator<T> {
    int pos;

    NonDestructiveIterator() {
      pos = size;
    }

    public boolean hasNext() {
      return pos > 0;
    }

    public T next() {
      pos--;
      if (pos < 0) {
        throw new NoSuchElementException();
      }
      return getElem(pos);
    }
  }

  private class DestructiveIterator implements java.util.Iterator<T> {
    public boolean hasNext() {
      return !isEmpty();
    }

    public T next() {
      return pop();
    }
  }

  @SuppressWarnings("unchecked") // safe because stack only stores type T elements
  private T getElem(int i) {
    return (T) array[i];
  }

  /**
   * Stack constructor. Stack has capacity that can be zero. If push is called and capacity is
   * reached capacity will be extended.
   *
   * @param _cap positive capacity
   * @throws IllegalArgumentException if _cap is negative
   */
  public Stack(int _cap) {
    if (_cap < 0) {
      throw new IllegalArgumentException("negative capacity");
    }
    size = 0;
    cap = _cap;
    array = new Object[cap];
  }

  /** Default stack constructor. Sets capacity to 16. */
  public Stack() {
    size = 0;
    cap = 16;
    array = new Object[cap];
  }

  /**
   * Get number of elements in stack.
   *
   * @return size of stack
   */
  public int count() {
    return size;
  }

  /**
   * Put element on top of existing elements in stack.
   *
   * @param value
   */
  public void push(T value) {
    size++;
    if (size >= cap) { // resize
      int newCap;
      if (cap == 0) {
        newCap = 16;
      } else {
        newCap = cap * 2;
      }
      Object[] newArray = new Object[newCap];
      System.arraycopy(array, 0, newArray, 0, cap);
      array = newArray;
      cap = newCap;
    }
    array[size - 1] = value;
  }

  /**
   * Pop element from the stack. Delete element on the top and return its value
   *
   * @return value from the stack top
   * @throws EmptyStackException if stack was empty
   */
  public T pop() {
    if (isEmpty()) {
      throw new EmptyStackException();
    }
    size--;
    return getElem(size);
  }

  /**
   * Returns value from the top but does not change the stack.
   *
   * @return value from the stack top
   * @throws EmptyStackException if stack was empty
   */
  public T peek() {
    if (isEmpty()) {
      throw new EmptyStackException();
    }
    return getElem(size - 1);
  }

  /**
   * Check if stack is empty.
   *
   * @return true if empty, false if stack has elements
   */
  public boolean isEmpty() {
    return size == 0;
  }

  /**
   * Nondestructive iterator. Used to peek elements.
   *
   * @return nondestructive iterator
   */
  @Override
  public Iterator<T> iterator() {
    return new NonDestructiveIterator();
  }

  /**
   * Destructive iterator. Removes accessed elements. Used to pop elements.
   *
   * @return destructive iterator
   */
  public Iterator<T> iteratorD() {
    return new DestructiveIterator();
  }
}
