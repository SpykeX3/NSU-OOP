/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package ru.nsu.fit.chernikov.Task_2_2;

import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.EmptyStackException;
import java.util.Iterator;
import java.util.stream.Stream;

/**
 * Priority queue, extracts elements with maximal key.
 *
 * @param <K> type of key
 * @param <T> type of stored elements
 */
public class PQueue<K extends Comparable<K>, T> implements Iterable<T> {
  private class PList {
    private K priority;
    private T value;
    private PList next, prev;

    PList() {
      next = this;
      prev = this;
    }

    PList(K pr, T val) {
      priority = pr;
      value = val;
      next = this;
      prev = this;
    }

    T getValue() {
      return value;
    }

    PList insert(K pr, T val) {
      PList seeker = this.next;
      PList node = new PList(pr, val);
      while (seeker != this && seeker.priority.compareTo(node.priority) < 0) {
        seeker = seeker.next;
      }

      PList prv = seeker.prev;
      prv.next = node;
      seeker.prev = node;
      node.next = seeker;
      node.prev = prv;

      return node;
    }

    T pop() {
      if (prev == this) {
        throw new EmptyStackException();
      }
      T val = prev.getValue();
      prev.prev.next = this;
      this.prev = prev.prev;
      return val;
    }
  }

  /** Iterator with standard order. */
  private class PQIterator implements Iterator<T> {
    PList current;

    PQIterator() {
      current = head.prev;
    }

    @Override
    public boolean hasNext() {
      return current != head;
    }

    @Override
    public T next() {
      T res = current.value;
      current = current.prev;
      return res;
    }
  }

  private class PQEIterator implements Iterator<AbstractMap.SimpleEntry<K, T>> {
    PList current;

    PQEIterator() {
      current = head.prev;
    }

    @Override
    public boolean hasNext() {
      return current != head;
    }

    @Override
    public AbstractMap.SimpleEntry<K, T> next() {
      AbstractMap.SimpleEntry<K, T> res =
          new AbstractMap.SimpleEntry<>(current.priority, current.value);
      current = current.prev;
      return res;
    }
  }

  private PList head;
  private int count;

  /** PQueue constructor. */
  public PQueue() {
    head = new PList();
    count = 0;
  }

  /**
   * Insert an element in queue with priority.
   *
   * @param key priority of inserted element.
   * @param value to be stored.
   */
  public void insert(K key, T value) {
    head.insert(key, value);
    count++;
  }

  /**
   * Extracts element with highest priority.
   *
   * @return value with highest priority.
   */
  public T extract_minimum() {
    if (count == 0) {
      throw new EmptyStackException();
    }
    T val = head.pop();
    count--;
    return val;
  }

  /**
   * Get count of stored elements.
   *
   * @return count.
   */
  public int getCount() {
    return count;
  }

  /**
   * Get iterator. Will iterate with standard order without removing elements.
   *
   * @return iterator.
   */
  @Override
  public Iterator<T> iterator() {
    return new PQIterator();
  }

  public Stream<AbstractMap.SimpleEntry<K, T>> stream() {
    ArrayList<AbstractMap.SimpleEntry<K, T>> list = new ArrayList<>();
    PQEIterator iter = new PQEIterator();
    while (iter.hasNext()) {
      list.add(iter.next());
    }
    return list.stream();
  }
}
