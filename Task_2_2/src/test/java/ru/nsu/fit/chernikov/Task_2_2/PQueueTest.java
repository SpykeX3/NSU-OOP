/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package ru.nsu.fit.chernikov.Task_2_2;

import org.junit.Test;
import java.util.EmptyStackException;

import static org.junit.Assert.*;

public class PQueueTest {
  @Test
  public void testExample() {
    PQueue<Integer, String> pq = new PQueue<>();
    pq.insert(200, "собака");
    pq.insert(10, "человек");
    String extracted = pq.extrack_minimum();
    assertEquals("собака", extracted);
    pq.insert(5, "пингвин");
    pq.insert(500, "попугай");
    extracted = pq.extrack_minimum();
    assertEquals("попугай", extracted);
    extracted = pq.extrack_minimum();
    assertEquals("человек", extracted);
    extracted = pq.extrack_minimum();
    assertEquals("пингвин", extracted);
  }

  @Test
  public void emptyException() {}

  @Test
  public void testSorted() {
    PQueue<Integer, Integer> pq = new PQueue<>();
    for (int i = 0; i < 15; i++) {
      pq.insert(i, i + 100);
    }
    for (int i = 14; i >= 0; i--) {
      assertEquals(i + 100, (long) pq.extrack_minimum());
    }
  }

  @Test
  public void testReversed() {
    PQueue<Integer, Integer> pq = new PQueue<>();
    for (int i = 0; i < 15; i++) {
      pq.insert(-i, i + 100);
    }
    for (int i = 0; i < 15; i++) {
      assertEquals(i + 100, (long) pq.extrack_minimum());
    }
  }

  @Test
  public void testSortedLarge() {
    PQueue<Integer, Integer> pq = new PQueue<>();
    long startTime = System.nanoTime();

    for (int i = 0; i < 15000; i++) {
      pq.insert(i, i + 100);
    }
    long insertedTime = System.nanoTime();
    for (int i = 14999; i >= 0; i--) {
      assertEquals(i + 100, (long) pq.extrack_minimum());
    }
    long endTime = System.nanoTime();
    System.out.println("15k queue worst case: "); // Tested to be 673-3704ms
    System.out.println(
        (insertedTime - startTime) / 1000000
            + "ms insertion\t\t"
            + (endTime - insertedTime) / 1000000
            + "ms extraction\t\t"
            + (endTime - startTime) / 1000000
            + "ms total");
  }

  @Test
  public void testReversedLarge() {
    long startTime = System.nanoTime();
    PQueue<Integer, Integer> pq = new PQueue<>();
    for (int i = 0; i < 15000; i++) {
      pq.insert(-i, i + 100);
    }
    long insertedTime = System.nanoTime();
    for (int i = 0; i < 15000; i++) {
      assertEquals(i + 100, (long) pq.extrack_minimum());
    }
    long endTime = System.nanoTime();
    System.out.println("15k queue best case: ");
    System.out.println(
        (insertedTime - startTime) / 1000000
            + "ms insertion\t\t"
            + (endTime - insertedTime) / 1000000
            + "ms extraction\t\t"
            + (endTime - startTime) / 1000000
            + "ms total");
  }

  @Test(expected = EmptyStackException.class)
  public void testEmptyExceptionUsed() {
    PQueue<Integer, Integer> pq = new PQueue<>();
    try {
      pq.insert(0, 0);
      pq.insert(0, 1);
      pq.insert(0, 2);
      pq.extrack_minimum();
      pq.extrack_minimum();
      pq.extrack_minimum();
    } catch (EmptyStackException e) {
      fail();
    }
    pq.extrack_minimum();
  }

  @Test(expected = EmptyStackException.class)
  public void testEmptyExceptionUnused() {
    PQueue<Integer, Integer> pq = new PQueue<>();
    pq.extrack_minimum();
  }

  @Test
  public void testIterator() {
    PQueue<Integer, Integer> pq = new PQueue<>();
    for (int i = 0; i < 15; i++) {
      pq.insert(i, i + 100);
    }
    long expected = 114;
    for (Integer extracted : pq) {
      assertEquals(expected, (long) extracted);
      expected--;
    }
  }

  @Test
  public void testCount() {
    PQueue<Integer, Integer> pq = new PQueue<>();
    for (int i = 0; i < 15; i++) {
      pq.insert(i, i + 100);
    }
    int expected = 15;
    assertEquals(expected, pq.getCount());
    for (int i = 15; i > 0; i--) {
      pq.extrack_minimum();
      expected--;
      assertEquals(expected, pq.getCount());
    }
    assertEquals(0, pq.getCount());
  }
}
